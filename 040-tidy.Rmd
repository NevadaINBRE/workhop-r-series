# Tidy R

## Introductions and Overview

## Tidy Data

### Identifying Not-Tidy data

### Practice

## Formatting Tidy Data

### pivot_longer

### pivot_wider

## Dealing with NA's

### Drop missing values

### Fill missing values

## Separating and Combining our Data

### What if one variable is spread across multiple columns?

### Or if multiple variables are contained in one column?

## Manipulating Tidy Data

### Grouping makes manipulating dataframes easy!

### Summarize

## Minimizing Repetition

### Purrr

purrr: part of the tidyverse, the basic function `map()` is very similar to the `apply` family of functions.
  - The goal is to minimize repetition, while maximizing replication. 
  - Keep your code D.R.Y.
  
The basic arguments for `map()` are:
`.x` - A list or vector (can be logical,integer,numeric,character)
`.f` - A function or formula

```{r 040-MooCow}
# the rnorm function is handy for making test datasets. What does rnorm do?
?rnorm()

library(tidyverse)
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
mn <- map_dbl(df, mean)
# notice you do not need the () after the function as you would if executing from console

# can pipe it an input to make the process even easier
df %>% map_dbl(mean)
```

Can't we just use our function on the character vector though?

```{r 040-MooCow2}
mean(df)

# No silly!
```
PRACTICE: Compute the mean, median, and sd of every column in the mtcars data.

MORE PRACTICE: Incorporate what we have learned in earlier workshops and create a function to output the mean, median and sd of the mtcars data and save it as a new variable.

EVEN MORE PRACTICE: If you are tracking these changes in a git repo, commit them to your github.



When viewing the ouput of the function that we applied to our dummy data, you may have noticed that while the values are correct, the ouput format is messy.
  - the base `map()` function will always output a list
  - what about if we want a numeric outcome? or a list of `chr` values that we can plot later?
  - `map_lgl()`, `map_int()`, `map_dbl()` and `map_chr()` return an atomic vector of the indicated type (or die trying).
Let's see how this works:
```{r 040-Lollipops}

sr_dbl <- map_dbl(df, sqrt)
# Should return a numerical vector rather than a list
view(sr_dbl)

```

What does map(-2:2, rnorm, n = 5) do? 

What about map_dbl(-2:2, rnorm, n = 5)? Why?

How do we interpret this error code?


Pretty Cool! But we can be even more efficient.

### Nested Data

What is nested data? If you know about lists, you are halfway there.

A nested data frame is just a normal data frame, but with more features. It still has columns and rows, but the content of the cells can be:
  - lists
  - models
  - other data frames
  - plots
When combined with the `map()` functions, we can manipulate a large amount of data very quickly. 

Now....what does this look like? We'll do some examples using the `gapminder` dataset:
```{r 040-Elephant Ear}

library(gapminder)

# Take a peak at the dataset
head(gapminder)

gapminder_nested <- gapminder %>% 
  group_by(continent) %>% 
  nest()

gapminder_nested
```
The first column is the variable that we grouped by, continent, and the second column is the rest of the data frame corresponding to that group (as if you had filtered the data frame to the specific continent). To see this, the code below shows that the first entry in the data column corresponds to the entire gapminder dataset for Asia.

```{r 040-gapminder}
gapminder_nested$data[[1]]
```

So why nest a data frame? It doesn't seem very useful...until you realize you can use other dplyr functions to manipulate objects that can be stored in a list. 

However, many common functions like `mutate()` are applied directly to an entire column (usually a vector), there are problems trying to use these on a list. 
```{r 040-tutoreos}
gapminder_nested %>% 
  mutate(avg_lifeExp = mean(data$lifeExp))
```

I wanted to extract the life expectancy column from each data frame and create a new one. Why doesn't this work? (Hint: open the nested dataset and look at the column types)

Basically, we need to map the `mean()` function to our nested data. We will first try to do it for just one continent with the `pluck()` function, and then for the whole nested dataset:

```{r 040-Guitar Hero}
asia <- gapminder_nested %>% pluck('data', 1)
# Average life expectancy of Asia could be calculated by:
mean(asia$lifeExp)



gapminder_nested %>% 
  mutate(avg_lifeExp = map_dbl(data, ~{mean(.$lifeExp)}))
```
Bonus: What other functions could we have used to do this?


## Merging Tidy Data

### Bind

### Join







